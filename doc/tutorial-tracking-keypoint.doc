/**

\page tutorial-tracking-keypoint Tutorial: Keypoint tracking
\tableofcontents

\section tracking_keypoint_klt KLT tracker

With ViSP it is possible to track keypoints using OpenCV KLT tracker, an implementation of the Kanade-Lucas-Tomasi feature tracker. The following example code available in tutorial-klt-tracker.cpp shows how to use ViSP vpKltOpencv class to this end. This class is a wrapper over the OpenCV KLT tracker implementation.

\include tutorial-klt-tracker.cpp

The video shows the result of the tracking:

\htmlonly
<iframe width="420" height="315" src="http://www.youtube.com/embed/ZYOG4kJPtaM?rel=0" frameborder="0" allowfullscreen></iframe>
\endhtmlonly

And here is the line by line explanation of the source : 

\snippet tutorial-klt-tracker.cpp Include

We include here the headers that define the corresponding classes. vpImageConvert class will be used to convert ViSP images implemented in vpImage class into OpenCV IplImage structure used as an entry by the KLT tracker. Then we include the header of vpKltOpencv class which is the wrapper over OpenCV KLT tracker implementation. We need also to include a device to display the images. We retain vpDisplayOpenCV that works on Unix and Windows since OpenCV is mandatory by the tracker. Finally we include vpVideoReader header that will be used to read an mpeg input stream.

\snippet tutorial-klt-tracker.cpp Check 3rd party

We use the previous macro to ensure that OpenCV at least version 1.1.0 requested by the tracker and the image viewer, and ffmpeg requested to read the video stream are available.

\snippet tutorial-klt-tracker.cpp Create reader

The program starts by the creation of a vpVideoReader instance able to extract all the images of the video file \c video-postcard.mpeg. Here, the video should be in the same folder than the binary.

\snippet tutorial-klt-tracker.cpp Acquire
Returns the first image of the video in the gray level ViSP image container \c I.

\snippet tutorial-klt-tracker.cpp Convert to OpenCV image

Then we convert \c I into \c cvI, an image in OpenCV IplImage format that will be used by the tracker.

\snippet tutorial-klt-tracker.cpp Init display
Create a window associated to \c I, at position (0,0) in the screen, with "Klt tracking" as title, and display image \c I. 
 
\snippet tutorial-klt-tracker.cpp Create tracker
 
Create an instance of the tracker, set parameters of the Harris keypoint detector.

\snippet tutorial-klt-tracker.cpp Init tracker

Finally initialize the tracker on \c cvI image.

\snippet tutorial-klt-tracker.cpp While loop

Until the end of the video is not reached, we get \c I the next image in ViSP format, display and convert it in IplImage format. Then we track the Harris keypoints using KLT tracker before displaying the keypoints that are tracked with a red cross.

\snippet tutorial-klt-tracker.cpp Wait click
We are waiting a mouse click event on image \c I to end the program.

With the following line, we release the memory allocated for the OpenCV IplImage \c cvI before ending the program.

\snippet tutorial-klt-tracker.cpp Release IplImage

\section tracking_keypoint_klt_init KLT tracker with re-initialisation

Once initialized, the number of tracked features decreases over the time. Depending on a criteria, it may sense to detect and track new features online. A possible criteria is for example to compare the number of currently tracked features to the initial number of detected features. If less than a given percentage of features are tracked, you can start a new detection. 

To get the number of detected or tracked features just call:

\code
  tracker.getNbFeatures();
\endcode

Then the idea is to add the previously tracked features to the list of features that are detected.

The example tutorial-klt-tracker-with-reinit.cpp shows how to do that. In that example we start a new detection on frame 25. Compared to the previous code available in tutorial-klt-tracker.cpp we add the following lines:

\code
      if (reader.getFrameIndex() == 25) {
        std::cout << "Re initialize the tracker" << std::endl;
#if (VISP_HAVE_OPENCV_VERSION >= 0x020408)
        // Save of previous features
        std::vector<cv::Point2f> prev_features = tracker.getFeatures();
 
        // Start a new feature detection
        tracker.initTracking(cvI);
        std::vector<cv::Point2f> new_features = tracker.getFeatures();

        // Add previous features if they are not to close to detected one
        double distance, minDistance_ = tracker.getMinDistance();
        bool is_redundant;
        for (size_t i=0; i < prev_features.size(); i++) {
          // Test if a previous feature is not redundant with one of the newly detected
          is_redundant = false;
          for (size_t j=0; j < new_features.size(); j++){
            distance = sqrt(vpMath::sqr(new_features[j].x-prev_features[i].x) 
                       + vpMath::sqr(new_features[j].y-prev_features[i].y));
            if(distance < minDistance_){
              is_redundant = true;
              break;
            }
          }
          if(is_redundant){
            continue;
          }
          //std::cout << "Add previous feature with index " << i << std::endl;
          tracker.addFeature(prev_features[i]);
        }
#else
      ...
#endif
      }
      // Track the features
      tracker.track(cvI);
\endcode

In this code we do the following:
- save the features that are tracked until now
- initialize the tracker to detect new features
- parse all the saved features and compare them to the newly detected features. If a previous feature is close in terms of geometric distanceto a newly detected one, it is rejected (in our case less than 2 pixels). If not, it is added to the list of detected features. 
 
You are now ready to see the next \ref tutorial-tracking-me.

*/
