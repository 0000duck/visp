
/**
  \page tutorial-getting-started Tutorial: Getting started
  \tableofcontents


  \note We assume that you have successfully installed ViSP as described in the previous \ref tutorial-install-ubuntu.

The easiest way of using ViSP in your project is to use <a href="http://www.cmake.org/">CMake</a>. If you are not familiar with CMake, you can check the <a href="http://www.cmake.org/cmake/help/cmake_tutorial.html">tutorial</a>.

\section image_code Create a program using ViSP
Let's start to write our first program to see how to read an image and
  open a  window to display the image. This simple program is provided in tutorial-viewer.cpp example and given below:

\include tutorial-viewer.cpp

Here is the detailed explanation of the source, line by line :
\code
#include <visp/vpDisplayD3D.h>
#include <visp/vpDisplayGDI.h>
#include <visp/vpDisplayGTk.h>
#include <visp/vpDisplayX.h>
#include <visp/vpDisplayOpenCV.h>
\endcode
  Include all the headers for image viewers. The two first one are for Windows systems. They require that Direct 3D or the \e Graphical \e Device \e Interface (\e GDI) coming with the installation of Visual Studio are available. The third one needs GTK that is cross-platform. The fourth is for unix-like systems and requires that \e libX11 is available. The last one is also cross-platform and requires that OpenCV is available. 

\code
#include <visp/vpImageIo.h>
\endcode
Include the header that allows to read/write PGM, PPM, PNG and JPEG images from the disk using vpImageIo class.

\code
vpImage<vpRGBa> I;
\endcode
Create an instance of a color image where each pixel is coded in RGBa.

\code
try {
  vpImageIo::read(I, argv[1]);
}
catch(...) {
  std::cout << "Cannot read image \"" << argv[1] << "\"" << std::endl;
}
\endcode
The image \c I is initialized by reading an image file from the disk. If the image format is not supported we throw an exception.

\code
#if defined(VISP_HAVE_X11)
vpDisplayX d(I);
#elif defined(VISP_HAVE_OPENCV)
vpDisplayOpenCV d(I);
#elif defined(VISP_HAVE_GTK)
vpDisplayGTK d(I);
#elif defined(VISP_HAVE_GDI)
vpDisplayGDI d(I);
#elif defined(VISP_HAVE_D3D9)
vpDisplayD3d d(I);
#else
std::cout << "No image viewer is available..." << std::endl;
#endif
\endcode
Create an instance of an image display window for image \c I. The first viewer that is available is used. Here we create the link between the image \c I and the display \c d. Note that an image can only have one display. 

\code
 vpDisplay::setTitle(I, "My image");
\endcode
The title of the display is then set to \c "My image".  

\code
  vpDisplay::display(I);
  vpDisplay::flush(I);
\endcode
  First we display the content of the image \c I, then we flush the display to render the image.

\code
  vpDisplay::getClick(I);
\endcode
  Here we handle mouse events. We are waiting for a blocking mouse click to end the program.

\section image_cmake Create a CMake file

Now you have to create your CMakeLists.txt file. It should look like this:

\code
project(tutorial-image)

cmake_minimum_required(VERSION 2.6)

find_package(VISP REQUIRED)
if(VISP_FOUND)
  include(${VISP_USE_FILE})
endif(VISP_FOUND)

add_executable(tutorial-viewer tutorial-viewer.cpp)
\endcode

\section image_build Generate the executable

Proceed as with any other project using CMake:

\code
cmake .
make
\endcode

\section image_output Run the executable

By now you sould have an executable called \c tutorial-viewer. You just have to run it giving an image location as an argument:

\code
./tutorial_viewer lena.ppm
\endcode


Here is a screen shot of the resulting output window :

  \image html img-lena.png


You are now ready to see the next \ref tutorial-grabber.
*/
