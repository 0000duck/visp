{
    "module_imports": [ "java.lang.String" ],
    "class_ignore_list" : [
        "vpClient",
        "vpRequest",
        "vpNetwork",
        "vpServer",
        "vpUDPClient",
		"vpUDPServer",
		"vpSerial",
		"vpIoTools",
		"vpCPUFeatures"
    ],
    "missing_consts" : {
        "Core" : {
            "public" : [
                ["SVD_MODIFY_A", 1], ["SVD_NO_UV", 2], ["SVD_FULL_UV", 4],
                ["FILLED", -1],
                ["REDUCE_SUM", 0], ["REDUCE_AVG", 1], ["REDUCE_MAX", 2], ["REDUCE_MIN", 3]
            ]
        }
    },
    "ManualFuncs" : {
        "Core" : {
            "minMaxLoc" : {
                "j_code"   : [
                    "// manual port",
                    "public static class MinMaxLocResult {",
                    "    public double minVal;",
                    "    public double maxVal;",
                    "    public Point minLoc;",
                    "    public Point maxLoc;",
                    "\n",
                    "    public MinMaxLocResult() {",
                    "        minVal=0; maxVal=0;",
                    "        minLoc=new Point();",
                    "        maxLoc=new Point();",
                    "    }",
                    "}",
                    "\n",
                    "// C++: minMaxLoc(Mat src, double* minVal, double* maxVal=0, Point* minLoc=0, Point* maxLoc=0, InputArray mask=noArray())",
                    "\n",
                    "//javadoc: minMaxLoc(src, mask)",
                    "public static MinMaxLocResult minMaxLoc(Mat src, Mat mask) {",
                    "    MinMaxLocResult res = new MinMaxLocResult();",
                    "    long maskNativeObj=0;",
                    "    if (mask != null) {",
                    "        maskNativeObj=mask.nativeObj;",
                    "    }",
                    "    double resarr[] = n_minMaxLocManual(src.nativeObj, maskNativeObj);",
                    "    res.minVal=resarr[0];",
                    "    res.maxVal=resarr[1];",
                    "    res.minLoc.x=resarr[2];",
                    "    res.minLoc.y=resarr[3];",
                    "    res.maxLoc.x=resarr[4];",
                    "    res.maxLoc.y=resarr[5];",
                    "    return res;",
                    "}",
                    "\n",
                    "//javadoc: minMaxLoc(src)",
                    "public static MinMaxLocResult minMaxLoc(Mat src) {",
                    "    return minMaxLoc(src, null);",
                    "}"
                ],
                "jn_code"  : [
                    "private static native double[] n_minMaxLocManual(long src_nativeObj, long mask_nativeObj);\n"
                ],
                "cpp_code" : [
                    "// C++: minMaxLoc(Mat src, double* minVal, double* maxVal=0, Point* minLoc=0, Point* maxLoc=0, InputArray mask=noArray())",
                    "JNIEXPORT jdoubleArray JNICALL Java_org_opencv_core_Core_n_1minMaxLocManual (JNIEnv*, jclass, jlong, jlong);",
                    "\n",
                    "JNIEXPORT jdoubleArray JNICALL Java_org_opencv_core_Core_n_1minMaxLocManual",
                    "  (JNIEnv* env, jclass, jlong src_nativeObj, jlong mask_nativeObj)",
                    "{",
                    "    try {",
                    "        LOGD(\"Core::n_1minMaxLoc()\");",
                    "        jdoubleArray result;",
                    "        result = env->NewDoubleArray(6);",
                    "        if (result == NULL) {",
                    "            return NULL; /* out of memory error thrown */",
                    "        }",
                    "\n",
                    "        Mat& src = *((Mat*)src_nativeObj);",
                    "\n",
                    "        double minVal, maxVal;",
                    "        Point minLoc, maxLoc;",
                    "        if (mask_nativeObj != 0) {",
                    "            Mat& mask = *((Mat*)mask_nativeObj);",
                    "            minMaxLoc(src, &minVal, &maxVal, &minLoc, &maxLoc, mask);",
                    "        } else {",
                    "            minMaxLoc(src, &minVal, &maxVal, &minLoc, &maxLoc);",
                    "        }",
                    "\n",
                    "        jdouble fill[6];",
                    "        fill[0]=minVal;",
                    "        fill[1]=maxVal;",
                    "        fill[2]=minLoc.x;",
                    "        fill[3]=minLoc.y;",
                    "        fill[4]=maxLoc.x;",
                    "        fill[5]=maxLoc.y;",
                    "\n",
                    "        env->SetDoubleArrayRegion(result, 0, 6, fill);",
                    "\n",
                    "    return result;",
                    "\n",
                    "    } catch(const cv::Exception& e) {",
                    "        LOGD(\"Core::n_1minMaxLoc() caught cv::Exception: %s\", e.what());",
                    "        jclass je = env->FindClass(\"org/opencv/core/VpException\");",
                    "        if(!je) je = env->FindClass(\"java/lang/Exception\");",
                    "        env->ThrowNew(je, e.what());",
                    "        return NULL;",
                    "    } catch (...) {",
                    "        LOGD(\"Core::n_1minMaxLoc() caught unknown exception (...)\");",
                    "        jclass je = env->FindClass(\"java/lang/Exception\");",
                    "        env->ThrowNew(je, \"Unknown exception in JNI code {core::minMaxLoc()}\");",
                    "        return NULL;",
                    "    }",
                    "}",
                    "\n"
                ]
            }
        }
    },
    "func_arg_fix" : {
        "randu"    : { "low"  : {"ctype" : "double"},
                       "high" : {"ctype" : "double"} },
        "randn"    : { "mean" : {"ctype" : "double"},
                       "stddev" : {"ctype"  : "double"} },
        "inRange"  : { "lowerb" : {"ctype" : "Scalar"},
                       "upperb" : {"ctype" : "Scalar"} },
        "boundingRect"   : { "points" : {"ctype" : "vector_Point"} },
        "hconcat" : { "src" : {"ctype" : "vector_Mat"} },
        "vconcat" : { "src" : {"ctype" : "vector_Mat"} },
        "checkRange" : {"pos" : {"ctype" : "*"} },
        "meanStdDev" : { "mean"   : {"ctype" : "vector_double"},
                         "stddev" : {"ctype" : "vector_double"} },
        "mixChannels" : { "dst" : {"attrib" : []} }
    },
    "type_dict" : {
        "vpMatrix": {
            "j_type": "VpMatrix",
            "jn_args": [
                [
                    "__int64",
                    ".nativeObj"
                ]
            ],
            "jn_type": "long",
            "jni_type": "jlong",
            "jni_var": "vpMatrix& %(n)s = *((vpMatrix*)%(n)s_nativeObj)",
            "suffix": "J",
            "j_import": "org.visp.core.VpMatrix"
        },
        "Moments": {
            "j_type": "Moments",
            "jn_args": [
                [
                    "double",
                    ".m00"
                ],
                [
                    "double",
                    ".m10"
                ],
                [
                    "double",
                    ".m01"
                ],
                [
                    "double",
                    ".m20"
                ],
                [
                    "double",
                    ".m11"
                ],
                [
                    "double",
                    ".m02"
                ],
                [
                    "double",
                    ".m30"
                ],
                [
                    "double",
                    ".m21"
                ],
                [
                    "double",
                    ".m12"
                ],
                [
                    "double",
                    ".m03"
                ]
            ],
            "jni_type": "jdoubleArray",
            "jni_var": "Moments %(n)s(%(n)s_m00, %(n)s_m10, %(n)s_m01, %(n)s_m20, %(n)s_m11, %(n)s_m02, %(n)s_m30, %(n)s_m21, %(n)s_m12, %(n)s_m03)",
            "suffix": "DDDDDDDDDD"
        },
        "Point": {
            "j_type": "Point",
            "jn_args": [
                [
                    "double",
                    ".x"
                ],
                [
                    "double",
                    ".y"
                ]
            ],
            "jni_type": "jdoubleArray",
            "jni_var": "Point %(n)s((int)%(n)s_x, (int)%(n)s_y)",
            "suffix": "DD",
            "j_import": "org.visp.core.Point"
        },
        "String": {
            "j_type": "String",
            "jn_type": "String",
            "jni_name": "n_%(n)s",
            "jni_type": "jstring",
            "jni_var": "const char* utf_%(n)s = env->GetStringUTFChars(%(n)s, 0); String n_%(n)s( utf_%(n)s ? utf_%(n)s : \"\" ); env->ReleaseStringUTFChars(%(n)s, utf_%(n)s)",
            "suffix": "Ljava_lang_String_2",
            "j_import": "java.lang.String"
        },
        "c_string": {
            "j_type": "String",
            "jn_type": "String",
            "jni_name": "n_%(n)s.c_str()",
            "jni_type": "jstring",
            "jni_var": "const char* utf_%(n)s = env->GetStringUTFChars(%(n)s, 0); String n_%(n)s( utf_%(n)s ? utf_%(n)s : \"\" ); env->ReleaseStringUTFChars(%(n)s, utf_%(n)s)",
            "suffix": "Ljava_lang_String_2",
            "j_import": "java.lang.String"
        },
        "size_t": {
            "j_type": "long",
            "jn_type": "long",
            "jni_type": "jlong",
            "suffix": "J"
        },
        "vector_vpMatrix": {
            "j_type": "List<vpMatrix>",
            "jn_type": "long",
            "jni_type": "jlong",
            "jni_var": "std::vector<vpMatrix> %(n)s",
            "suffix": "J",
            "v_type": "vpMatrix",
            "j_import": "org.visp.core.VpMatrix"
        }
    }
}
